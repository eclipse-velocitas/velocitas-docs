---
title: "Vehicle Signal Interface"
date: 2023-08-09T00:00:00+01:00
weight: 10
description: >
  The functional interface for providing vehicle signal access via VSS specification.

---

{{<table "table table-bordered">}}
| Providing CLI package       | Interface type-key               |
|-----------------------------|----------------------------------|
| `devenv-devcontainer-setup` | `vehicle-signal-interface`       |
{{</table>}}

The _Vehicle Signal Interface_ formerly known as [_Vehicle Model_](/docs/concepts/development_model/#vehicle-models) interface type creates an interface to a signal interface described by the VSS spec. This interface will generate a source code package equivalent to the contents of your VSS JSON automatically upon devContainer creation.

If a _Vehicle App_ requires a `vehicle-signal-interface`, it will act as a consumer of datapoints already available in the system. If, on the other hand, a _Vehicle App_ provides a `vehicle-signal-interface`, it will act as a provider (formerly feeder in KUKSA terms) of the declared datapoints.

Furthermore, in the source code generated by this functional interface, a connection to [KUKSA Databroker](https://github.com/eclipse-kuksa/kuksa-databroker) will be established via the configured Velocitas middleware. It uses the `broker.proto` if provided by the KUKSA Databroker to connect via gRPC. A seperate declaration of a `grpc-interface` for the databroker is **NOT** required.

More information: [Vehicle Model Creation](/docs/tutorials/vehicle_model_creation/)

## Configuration structure

{{<table "table table-bordered">}}
| Attribute | Type | Example value | Description |
|-|-|-|-|
| `src` | string | `"https://github.com/COVESA/vehicle_signal_specification/releases/download/v3.0/vss_rel_3.0.json"` | URI of the used COVESA Vehicle Signal Specification JSON export. URI may point to a local file or to a file provided by a server. |
| `unit_src` | string | `["abs_path_unit_file_1", "abs_path_unit_file_2", "uri_unit_file_3"]` | An array of URI's/absolute path's of the used COVESA Vehicle Signal Specification unit file(s) in yaml format. URI may point to a local file or to a file provided by a server. If none is provided a default one will be used (https://github.com/COVESA/vehicle_signal_specification/blob/v4.0/spec/units.yaml). |
| `datapoints` | object | Object containing both required and provided datapoints. |
| `datapoints.required` | array | Array of required datapoints. |
| `datapoints.required.[].path` | string | `Vehicle.Speed` | Path of the VSS datapoint. |
| `datapoints.required.[].optional` | boolean? | `true`, `false` | Is the datapoint optional, i.e. can the _Vehicle App_ work without the datapoint being present in the system. Defaults to `false`. |
| `datapoints.required.[].access` | string | `read`, `write` | What kind of access to the datapoint is needed by the application. |
| `datapoints.provided` | array | Array of provided datapoints. |
| `datapoints.provided.[].path` | string | `Vehicle.Cabin.Seat.Row1.Pos1.Position` | Path of the VSS datapoint. |
{{</table>}}

## Example

```json
{
    "type": "vehicle-signal-interface",
    "config": {
        "src": "https://github.com/COVESA/vehicle_signal_specification/releases/download/v3.0/vss_rel_3.0.json",
        "datapoints": {
            "required": [
                {
                    "path": "Vehicle.Speed",
                    "access": "read"
                },
                {
                    "path": "Vehicle.Body.Horn.IsActive",
                    "optional": true,
                    "access": "write"
                }
            ],
            "provided": [
                {
                    "path": "Vehicle.Cabin.Seat.Row1.Pos1.Position"
                }
            ]
        }
    }
}
```

## Different VSS versions

The model generation is supported for VSS versions up to v4.0. There are some changes for some paths from v3.0 to v4.0. For example `Vehicle.Cabin.Seat.Row1.Pos1.Position` in v3.0 is `Vehicle.Cabin.Seat.Row1.DriverSide.Position` in v4.0. If you are using the mock provider you would need to take that into account when you sepcify your mock.py.
